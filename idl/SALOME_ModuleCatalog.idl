//  Copyright (C) 2007-2008  CEA/DEN, EDF R&D, OPEN CASCADE
//
//  Copyright (C) 2003-2007  OPEN CASCADE, EADS/CCR, LIP6, CEA/DEN,
//  CEDRAT, EDF R&D, LEG, PRINCIPIA R&D, BUREAU VERITAS
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
//
//  See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
//
//  File   : SALOME_ModuleCatalog.idl
//  Author : Estelle Deville
//  $Header$
//
/*! \file SALOME_ModuleCatalog.idl This file conatins a set of interfaces used for  
  creation of the catalog of components in %SALOME application
*/

/*!  
The main package of interfaces used for creation of the module catalog in %SALOME application.
Module catalog allows to manage components of %SALOME application, to call specified in the
xml files interfaces with the help of AComponent interface.
*/
module SALOME_ModuleCatalog
{
  // Type Definitions
/*! 
This enumeration contains a current set of definitions of the components integrated
into %SALOME application.
*/
  enum ComponentType {  GEOM,  /*!<Module %GEOM */
                        MESH,  /*!<Module %MESH */
                         Med,  /*!<Module %Med*/
                      SOLVER,  /*!<Module of %SOLVER type */
                        DATA,  /*!<Module %DATA */
                        VISU,  /*!<Module %VISU */
                      SUPERV,  /*!<Module %SUPERVISION */
                       OTHER   /*!<Any other type of module */
                     } ;
/*! 
This struct contains fields defining the parameter of the service.
*/

  struct ServicesParameter
  {
    string Parametertype; /*!<Type of the parameter.*/
    string Parametername; /*!<Name of the parameter.*/
  } ;

  enum DataStreamDependency {
    DATASTREAM_UNDEFINED,
    DATASTREAM_TEMPORAL,
    DATASTREAM_ITERATIVE
  } ;

  struct ServicesDataStreamParameter
  {
    string Parametertype;                     /*!<Type of the parameter.*/
    string Parametername;                     /*!<Name of the parameter.*/
    DataStreamDependency Parameterdependency; /*!<Temporal or iterative dependency.*/
  } ;

/*! 
The list of the parameters of service.
*/

  typedef sequence<ServicesParameter> ListOfServicesParameter;
  typedef sequence<ServicesDataStreamParameter> ListOfServicesDataStreamParameter;

  typedef sequence<string> ListOfString;
  enum TypeKind 
  {
    NONE     ,
    Dble   ,
    Int      ,
    Str   ,
    Bool     ,
    Objref   ,
    Seq ,
    Array    ,
    Struc 
  };
  struct MemberDefinition
  {
    string name; /*! Name of the member */
    string type; /*! Type of the member */
  };
  typedef sequence<MemberDefinition> ListOfMemberDefinition;
/*! 
 * Struct to get the definition of types used in Salome catalogs
 */
  struct TypeDefinition
  {
    string name; /*! Name of the type */
    TypeKind kind; /*! Kind of the type.*/
    string id; /*! id (if needed) */
    string content; /*! Content type (if needed) */
    ListOfString bases; /*! Content type (if needed) */
    ListOfMemberDefinition members; /*! Members types (if needed) */
  };

  typedef sequence<TypeDefinition> ListOfTypeDefinition;

/*! 
This struct contains fields completely defining each service.
*/

  struct Service
  {
    string                            ServiceName; /*!<Name of the service.*/
    ListOfServicesParameter           ServiceinParameter; /*!< List of input parameters of the services.*/
    ListOfServicesParameter           ServiceoutParameter; /*!< List of output parameters of the services.*/
    ListOfServicesDataStreamParameter ServiceinDataStreamParameter; /*!< List of input parameters of the services.*/
    ListOfServicesDataStreamParameter ServiceoutDataStreamParameter; /*!< List of output parameters of the services.*/
    boolean                           Servicebydefault; /*!<True if the service is taken with its default fields.*/
    boolean                           TypeOfNode; /*!<True is the service is a factory node. Otherwise, it's a compute node.*/
  } ;
/*! 
List of services of the interface.
*/
  typedef sequence<Service> ListOfInterfaceService;
/*! 
List of services.
*/
  typedef sequence<string> ListOfServices ;
/*! 
This struct contains fields defining each interface.
*/
  struct DefinitionInterface
  {
    string                 interfacename ; /*!<Name of the interface.*/
    ListOfInterfaceService interfaceservicelist ; /*!<List of services of the interface.*/
  } ;
/*! 
List of interface definitions.
*/
  typedef sequence<DefinitionInterface> ListOfDefInterface ;
/*! 
List of names of interfaces.
*/
  typedef sequence<string> ListOfInterfaces ;

/*!
PathPrefix : association of a machine name and
a path to a component
*/
  struct PathPrefix {
    string             machine;
    string             path;
  };

/*! 
List of path prefixes
*/
  typedef sequence<PathPrefix> PathPrefixes;

/*!
Implementation type
*/
  enum ImplType {
    SO,                       /* component implemented as a dynamic library loadable with dlopen */
    PY,                       /* component implemented as a python module loadable with import */
    EXE,                      /* component implemented as an executable */
    CEXE                      /* component to be loaded by a container which executable is given in the catalog */
  } ;

/*!
Description of a component
*/
  struct ComponentDef
  {
    ComponentType      type;
    string             name;
    string             username;
    boolean            multistudy;
    ImplType           implementationType;
    string             implname;
    string             icon;
    string             constraint;
    ListOfDefInterface interfaces;
    PathPrefixes       paths;
  };

/*! 
List of names of components.
*/
  typedef sequence<string> ListOfComponents ;
/*! 
List of names of computers.
*/
  typedef sequence<string> ListOfComputers ;
/*! 
This struct contains GUI elements used for representation of the module in %IAPP component.
*/
  struct IAPP_Affich
  {
    string modulename;     /*!<Name of the module.*/
    string moduleusername; /*!<UserName of the module.*/
    string moduleicone;    /*!<Icone representing the module.*/
    string moduleversion;  /*!<Version of the module.*/
    string modulecomment;  /*!<Comment to the module.*/
  };
/*!
List of pair GUI elements (component name, component icone)
 used for representation of the module in %IAPP component.
*/
  typedef sequence<IAPP_Affich> ListOfIAPP_Affich ;

/*! 
 This exception is raised when a %component, a %service or a % pathPrefix is not found.
*/
  exception NotFound
  {
    string what ; /*!<Indicates if it's a %component, a %service or a % pathPrefix.*/
  } ;

  /*!
   This interface provides the common funcionality information of corresponding component.
   Information is loaded from specific xml files.
  */
  interface Acomponent
  {
    // GetInterfaceList : operation to get a list of the interfaces name of
    //                    a component
  /*!
   Gets the list of names of interfaces of the component
    \return a list of interfaces of the component 
  */
    ListOfInterfaces GetInterfaceList() ;

    // GetInterface : operation to get one interface of a component
  
  /*! 
    Gets a definite interface of the component
    \note <BR>If the specified interface doesn't exist, Notfound exception is thrown
    \param interfacename  Name of the interface 
    \return Required interface
  */
    DefinitionInterface GetInterface(in string interfacename) raises(NotFound);

    // GetServiceList : operation to get a list of the services name of
    //                  an interface of a component
 /*! 
   Gets the list of names of services of a definite interface belonging to the component.
   \note <BR>If the specified interface doesn't exist, Notfound exception is thrown.
   \param interfacename Name of the interface 
   \return List of services of the required interface
 */
    ListOfServices GetServiceList(in string interfacename) raises(NotFound);

    
    // GetService : operation to get one service of an interface of a component
  
 /*! 
   Gets a definite service of an interface of the component.
   \note <BR>If the required service or the specified interface don't exist, Notfound exception is thrown.
   \param interfacename Name of the interface
   \param servicename Name of the service
   \return Required service
 */

    Service GetService(in string interfacename, 
		       in string servicename) raises(NotFound);

    // GetDefaultService : operation to get the default service
    //                     of an interface of a component
/*! 
   Gets the default service of an interface of the component.
   \note <BR>If the required service or the specified interface don't exist, Notfound exception is thrown.
   \param interfacename Name of the interface
   \return Required service
 */

    Service GetDefaultService(in string interfacename) raises(NotFound);

    // GetPathPrefix : operation to get the PathPrefix of a computer
 /*!  
   Gets the prefix path of the computer containing the %component.
   \note <BR>If the required computer doesn't exist, Notfound exception is thrown
   \param machinename Name of the machine 
   \return Prefix path
 */

    string GetPathPrefix(in string machinename) raises(NotFound);

/*! 
    Get the constraint affected to the component 
    (to be resolved by LifeCycle for the computer choice)
*/
    readonly attribute string constraint ;

/*! 
Get the name of the component
*/
    readonly attribute string componentname;

/*!
Get the user name of the component
*/
    readonly attribute string componentusername;

/*! 
Ask whether the component is multistudy or not
*/
    readonly attribute boolean multistudy;

/*! 
Ask the type of the component
*/
    readonly attribute ComponentType component_type ;

/*! 
Gets the icone of the component (for IAPP)
*/
    readonly attribute string component_icone;

/*! 
Gets the implementation type of the component : C++ (dyn lib), Python (module) or executable 
*/
    readonly attribute ImplType implementation_type;
/*! 
Gets the implementation name of the component : name of the dyn lib or the python module or the executable
if the default naming scheme is not convenient.
*/
    readonly attribute string implementation_name;
  } ;

/*! \brief %Module catalog interface

This interface is used for creation of the module catalog in %SALOME application.
*/
  interface ModuleCatalog
  {
    void ping();

/*!
    Returns the PID of the server
*/
    long getPID();

/*!
    Shutdown the ModuleCatalog process.
*/    
    oneway void ShutdownWithExit();

/*! 
 * Get the types of the catalog
 */   
    ListOfTypeDefinition GetTypes();

/*! 
 Gets a list of names of computers of the catalog 
*/   
    ListOfComputers GetComputerList();

/*! 
Gets the %PathPrefix of a computer
*/
    string GetPathPrefix(in string machinename) raises(NotFound);
/*! 
 Gets a list of names of components of the catalog 
*/   
    ListOfComponents GetComponentList();
/*! 
Gets a list of pair GUI elements (component name, component icone) 
used for representation of the module in %IAPP component.
*/

    ListOfIAPP_Affich GetComponentIconeList();
/*! 
Gets a list of names of components of a particular type, which belong to this catalog.
*/  
    // GetComponentList : operation to get a list of the components name of
    //                    a particular type of the catalog   
    ListOfComponents GetTypedComponentList(in ComponentType _component_type);

/*! 
Gets one component of the catalog.
*/
    Acomponent GetComponent(in string componentname) raises(NotFound);

/*! 
Gets the description of a component of the catalog.
*/
    ComponentDef GetComponentInfo(in string componentName) raises(NotFound);

/*!
Reads a xml file and imports new components from this file.
New components replace existing components with the same name.
*/
    void ImportXmlCatalogFile(in string filename) raises(NotFound);

    void shutdown();
  } ;
};
