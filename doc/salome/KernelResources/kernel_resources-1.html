<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.20">
 <TITLE>SALOME Kernel resources for developer: Trace and debug Utilities</TITLE>
 <LINK HREF="kernel_resources-2.html" REL=next>

 <LINK HREF="kernel_resources.html#toc1" REL=contents>
</HEAD>
<BODY>
<A HREF="kernel_resources-2.html">Next</A>
Previous
<A HREF="kernel_resources.html#toc1">Contents</A>
<HR>
<H2><A NAME="s1">1.</A> <A HREF="kernel_resources.html#toc1">Trace and debug Utilities</A></H2>

<P>During the development process, an execution log is useful to
identify problems. This log contains messages, variables values,
source files names and line numbers. It is recommended to verify
assertions on variables values and if necessary, to stop the execution
at debug time, in order to validate all parts of code.</P>

<H2><A NAME="ss1.1">1.1</A> <A HREF="kernel_resources.html#toc1.1">Two modes: debug and release</A>
</H2>

<P>The goal of debug mode is to check as many features as possible
during the early stages of the development process. The purpose of
the utilities provided in SALOME is to help the developer to add
detailed traces and check variables values, without writing a lot
of code.</P>

<P>When the code is assumed to be valid, the release mode optimizes
execution, in terms of speed, memory, and display only user level
messages.</P>

<P>But, some informations must always be displayed in both modes:
especially messages concerning environment or internal errors, with
version identification. When an end user is confronted to such a
message, he may refer to a configuration documentation or send the
message to the people in charge of SALOME installation, or to the
development team, following the kind of error.</P>

<H2><A NAME="ss1.2">1.2</A> <A HREF="kernel_resources.html#toc1.2">C++ Macros for trace and debug</A>
</H2>

<P>SALOME provides C++ macros for trace and debug. These macros
are in <CODE>SALOME/src/SALOMELocalTrace/utilities.h</CODE> and this file must
be included in C++ source. Some macros are activated only in debug
mode, others are always activated. To activate the debug mode, <CODE>_DEBUG_</CODE>
must be defined, which is the case when SALOME Makefiles are generated
from configure, without options. When <CODE>_DEBUG_</CODE> is undefined (release
mode: <CODE>configure --disable-debug --enable-production</CODE>), the debug mode
macros are defined empty (they do nothing). So, when switching from
debug to release, it is possible (and recommended) to let the macro
calls unchanged in the source.</P>

<P>All the macros generate trace messages, stored in a circular
buffer pool. A separate thread reads the messages in the buffer pool,
and, depending on options given at SALOME start, writes the messages
on the standard output, a file, or send them via CORBA, in case of
a multi machine configuration.</P>

<P>Three informations are systematically added in front of the information
displayed:</P>

<P>
<UL>
<LI>the thread number from which the message come from;</LI>
<LI>the name of the source file in which the macros is set;</LI>
<LI>the line number of the source file at which the macro is set.
</LI>
</UL>
</P>
<H3>Macros defined in debug and release modes</H3>

<H3>INFOS_COMPILATION</H3>

<P>The C++ macro <CODE>INFOS_COMPILATION</CODE> writes on the trace buffer pool
informations about the compiling process: </P>

<P>
<UL>
<LI>the name of the compiler : <CODE>g++, KCC, CC, pgCC</CODE>;</LI>
<LI>the date and the time of the compiling processing process.
</LI>
</UL>
</P>
<P>This macro <CODE>INFOS_COMPILATION</CODE> does not have any argument. Moreover,
it is defined in both compiling mode : <CODE>_DEBUG_</CODE> and <CODE>_RELEASE_</CODE>.</P>

<P>Example :</P>

<P>
<PRE>
#include &quot;utilities.h&quot;
int main(int argc , char **argv) 
{ 
  INFOS_COMPILATION;
  ...
}
</PRE>
</P>
<H3>INFOS(str)</H3>

<P>In both compiling mode <CODE>_DEBUG_</CODE> and <CODE>_RELEASE_</CODE>, The C++ macro <CODE>INFOS</CODE>
writes on the trace buffer pool the string which has been passed
in argument by the user.</P>

<P>Example : </P>

<P>
<PRE>
#include &quot;utilities.h&quot;
int main(int argc , char **argv)
{ 
  ... 
  INFOS(&quot;NORMAL END OF THE PROCESS&quot;); 
  return 0; 
}
</PRE>
</P>
<P>displays :</P>

<P>
<PRE>
main.cxx [5] : NORMAL END OF THE PROCESS

</PRE>
</P>
<H3>INTERRUPTION(str)</H3>

<P>In both compiling mode <CODE>_DEBUG_</CODE> and <CODE>_RELEASE_</CODE>, The C++ macro <CODE>INTERRUPTION</CODE>
writes on the trace buffer pool the string, with a special <CODE>ABORT</CODE>
type. When the thread in charge of collecting messages finds this
message, it terminates the application, after message treatment.</P>

<H3>IMMEDIATE_ABORT(str)</H3>

<P>In both compiling mode <CODE>_DEBUG_</CODE> and <CODE>_RELEASE_</CODE>, The C++ macro <CODE>IMMEDIATE_ABORT</CODE>
writes the message immediately on standard error and exits the application.
Remaining messages not treated by the message collector thread are
lost.</P>

<H3>Macros defined only in debug mode</H3>

<H3>MESSAGE(str)</H3>

<P>In <CODE>_DEBUG_</CODE> compiling mode only, the C++ macro <CODE>MESSAGE</CODE> writes
on the trace buffer pool the string which has been passed in argument
by the user. In <CODE>_RELEASE_</CODE> compiling mode, this macro is blank.</P>

<P>Example : </P>

<P>
<PRE>
#include &quot;utilities.h&quot; 
#include &lt;string&gt; 
using namespace std; 
int main(int argc , char **argv) 
{ 
  ... 
  const char *str = &quot;Salome&quot;;
  MESSAGE(str);
  ... const string st; 
  st = &quot;Aster&quot;; 
  MESSAGE(c_str(st+&quot; and CASTEM&quot;)); 
  return 0;
}
</PRE>
</P>
<P>displays :</P>

<P>
<PRE>
- Trace main.cxx [8] : Salome
- Trace main.cxx [12] : Aster and CASTEM
</PRE>
</P>
<H3>BEGIN_OF(func_name)</H3>

<P>In <CODE>_DEBUG_</CODE> compiling mode, The C++ macro <CODE>BEGIN_OF</CODE> appends the
string <CODE>&quot;Begin of &quot;</CODE> to the one passed in argument by the
user and displays the result on the trace buffer pool. In <CODE>_RELEASE_</CODE>
compiling mode, this macro is blank.</P>

<P>Example : </P>

<P>
<PRE>
#include &quot;utilities.h&quot; 
int main(int argc , char **argv) 
{ 
  BEGIN_OF(argv[0]);
  return 0;
}
</PRE>
</P>
<P>displays : </P>

<P>
<PRE>
- Trace main.cxx [3] : Begin of a.out
</PRE>
</P>
<H3>END_OF(func_name)</H3>

<P>In <CODE>_DEBUG_</CODE> compiling mode, The C++ macro <CODE>END_OF</CODE> appends the string
<CODE>&quot;Normal end of &quot;</CODE> to the one passed in argument by the user
and displays the result on the trace buffer pool. In <CODE>_RELEASE_</CODE> compiling
mode, this macro is blank.</P>

<P>Example : </P>

<P>
<PRE>
#include &quot;utilities.h&quot; 
int main(int argc , char **argv) 
{ 
  END_OF(argv[0]);
  return 0; 
}
</PRE>
</P>
<P>displays : </P>

<P>
<PRE>
- Trace main.cxx [4] : Normal end of a.out
</PRE>
</P>
<H3>SCRUTE(var)</H3>

<P>In <CODE>_DEBUG_</CODE> compiling mode, The C++ macro <CODE>SCRUTE</CODE> displays its
argument which is an application variable followed by the value of
the variable. In <CODE>_RELEASE_</CODE> compiling mode, this macro is blank.</P>

<P>Example : </P>

<P>
<PRE>
#include &quot;utilities.h&quot;
int main(int argc , char **argv) 
{ 
  const int i=999;
  if( i &gt; 0 ) SCRUTE(i) ; i=i+1;
  return 0;
}
</PRE>
</P>
<P>displays :</P>

<P>
<PRE>
- Trace main.cxx [5] : i=999
</PRE>
</P>
<H3>ASSERT(condition)</H3>

<P>In <CODE>_DEBUG_</CODE> compiling mode only, The C++ macro <CODE>ASSERT</CODE> checks the
expression passed in argument to be not NULL. If it is NULL the condition
is written with the macro <CODE>INTERRUPTION</CODE> (see above). The process exits
after trace of this last message. In <CODE>_RELEASE_</CODE> compiling mode, this
macro is blank. N.B. : if <CODE>ASSERT</CODE> is already defined, this macro is
ignored.</P>

<P>Example :</P>

<P>
<PRE>
#include &quot;utilities.h&quot; 
... 
const char *ptrS = fonc();
ASSERT(ptrS!=NULL); 
cout &lt;&lt; strlen(ptrS); 
float table[10];
int k;
... 
ASSERT(k&lt;10);
cout &lt;&lt; table[k];
</PRE>
</P>
<HR>
<A HREF="kernel_resources-2.html">Next</A>
Previous
<A HREF="kernel_resources.html#toc1">Contents</A>
</BODY>
</HTML>
